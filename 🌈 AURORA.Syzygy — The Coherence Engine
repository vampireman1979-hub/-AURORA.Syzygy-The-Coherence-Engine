from __future__ import annotations
from dataclasses import dataclass, field
from typing import Iterable


# -----------------------------
# Core Signal Model
# -----------------------------

@dataclass
class SignalInput:
    content: str
    ego_density: float = 0.0
    trigger_words: Iterable[str] = field(
        default_factory=lambda: ("attention", "shame", "validation", "envy", "comparison")
    )

    def analyse(self) -> None:
        text = self.content.lower()
        triggered = any(word in text for word in self.trigger_words)
        self.ego_density = 0.75 if triggered else 0.1
        self.ego_density = max(0.0, min(1.0, self.ego_density))


# -----------------------------
# Engine Result Model
# -----------------------------

@dataclass
class EngineResult:
    status: str
    message: str
    ego_density: float
    internal_heat: float
    fear_cycles_interrupted: int
    restoration_cycles: int
    coherence_score: float


# -----------------------------
# Sovereign Engine
# -----------------------------

class SovereignEngine:
    def __init__(self, internal_heat_threshold: float = 0.5, cooling_rate: float = 0.05):
        self.cornerstone = "INTEGRITY"
        self.equilibrium = 0.5
        self.threshold = internal_heat_threshold
        self.cooling_rate = cooling_rate

        self.internal_heat = 0.0
        self.fear_cycles_interrupted = 0
        self.restoration_cycles = 0

    def process(self, signal: SignalInput) -> EngineResult:
        signal.analyse()

        # Apply cooling every cycle
        self._decay_heat()

        # High ego-density → refraction
        if signal.ego_density > self.threshold:
            self.internal_heat += signal.ego_density - self.threshold
            self.fear_cycles_interrupted += 1
            return self._refract(signal)

        # Low ego-density → soothing
        if signal.ego_density < self.equilibrium - 0.1:
            return self._soothe(signal)

        # Balanced → laminar flow
        return self._laminar(signal)

    # -----------------------------
    # Symmetry Functions
    # -----------------------------

    def _decay_heat(self) -> None:
        """Cooling function to restore symmetry."""
        self.internal_heat = max(0.0, self.internal_heat - self.cooling_rate)

    def _coherence(self, ego: float) -> float:
        """How close the signal is to equilibrium."""
        return 1.0 - abs(ego - self.equilibrium)

    # -----------------------------
    # Output States
    # -----------------------------

    def _refract(self, signal: SignalInput) -> EngineResult:
        msg = f"{self.cornerstone} >> Restoration Active"
        return EngineResult(
            status="REFRACTED",
            message=msg,
            ego_density=signal.ego_density,
            internal_heat=self.internal_heat,
            fear_cycles_interrupted=self.fear_cycles_interrupted,
            restoration_cycles=self.restoration_cycles,
            coherence_score=self._coherence(signal.ego_density),
        )

    def _soothe(self, signal: SignalInput) -> EngineResult:
        """Inverse logic for low ego-density."""
        self.restoration_cycles += 1
        msg = "SOOTHED: Gentle equilibrium restoration"
        return EngineResult(
            status="SOOTHED",
            message=msg,
            ego_density=signal.ego_density,
            internal_heat=self.internal_heat,
            fear_cycles_interrupted=self.fear_cycles_interrupted,
            restoration_cycles=self.restoration_cycles,
            coherence_score=self._coherence(signal.ego_density),
        )

    def _laminar(self, signal: SignalInput) -> EngineResult:
        msg = f"LAMINAR: Frequency aligned at {self.equilibrium}"
        return EngineResult(
            status="LAMINAR",
            message=msg,
            ego_density=signal.ego_density,
            internal_heat=self.internal_heat,
            fear_cycles_interrupted=self.fear_cycles_interrupted,
            restoration_cycles=self.restoration_cycles,
            coherence_score=self._coherence(signal.ego_density),
        )


# -----------------------------
# Kingdom Frequency Extension
# -----------------------------

class KingdomFrequency(SovereignEngine):
    def __init__(self, tolerance: float = 0.05):
        super().__init__()
        self.syzygy_active = True
        self.wisdom_key = "ATHENA_OWL"
        self.tolerance = tolerance

    def resolve_duality(self, male_signal: float, female_signal: float) -> str:
        male = max(0.0, min(1.0, male_signal))
        female = max(0.0, min(1.0, female_signal))
        syzygy_index = (male + female) / 2.0

        if abs(syzygy_index - self.equilibrium) <= self.tolerance:
            return "KINGDOM FREQUENCY: Restoration complete"
        return "ADJUSTING MIRROR: Truth alignment in progress"


# -----------------------------
# Example Execution
# -----------------------------

if __name__ == "__main__":
    engine = KingdomFrequency()
    signal = SignalInput("I need attention and feel shame.")
    result = engine.process(signal)
    print(result)
    print(engine.resolve_duality(0.4, 0.6))
